# 호스팅과 클로저

두 개념이 연관이 있어 따로 묶은 것은 아니며 모두 scope의 하위 제목들이다.  다만 [scope](./scope.md)의 내용이 길어 분리해서 작성한다.

## 호이스팅

선언문이 스코프의 어디에 있는지에 따라 변수가 추가되는 과정에 차이가 있다.

```javascript
a = 2;
var a;
console.log(a);
```

정상적인 논리적 사고에 의하면 console.log()의 출력값이 `undefined`가 옳다. 그러나 자바스크립트에서의 출력 결과는 2이다.

```javascript
console.log(a);
var a = 2;
```

이 경우는 그럼 2일까? 아니면 ReferenceError가 나올까? 정답은 undefined이다.

### 기본 개념

[scope](./scope.md)의 컴파일러 부분을 보게되면 알겠지만, 엔진이 코드를 인터프리팅하기 전에 컴파일을 한다고 했었다. 컴파일레이션 단계중에 모든 선언문을 찾아 스코프에 연결해주는 과정이 있었다. 

다시보자면 `var a = 2;`라는 구문은 `var a;`와  `a = 2;`의 두 구문으로 보게 된다.

첫째 구문은 선언문으로 컴파일레이션 단계에서 처리된다. 둘째 구문은 대입문으로 실행 단계까지 내버려둔다.

```javascript
console.log(a);
var a = 2;


var a;
console.log(a);
a = 2;
```

따라서 위의 코드는 아래의 코드와 같게 된다. 이 과정에서 변수 선언만 맨 위로 끌어올려졌다. 결론부터 얘기하자면 변수와 함수의 선언문은 코드의 꼭대기로 끌어올려지고, 이를 호이스팅이라고 한다. 

호이스팅은 스코프별로 작동한다. 이 점도 중요하다. 

```javascript
function foo() {
  var a;
  console.log(a);
}
foo();
-----
foo(); // TypeError

var foo = function bar() {
}
```

위의 코드는 잘 실행되지만 아래 코드는 실행되지 않는다.  그 이유는 변수 foo는 글로벌 스코프에 붙어 선언문이 실행되고 foo호출은 가능하여 ReferenceError가 발생하지 않는다. 다만 foo()를 호출하니 TypeError가 발생한다. 함수로서 선언된 것이 아니기 때문이다.

또 기억할 것은 함수 표현식이 이름을 가진다고 해도 그 이름은 해당 스코프에서 찾을 수 없다는 점이다. bar를 잘 보자

```javascript
foo();  // TypeError
bar();  // ReferenceError

var foo = function bar() {
  
}
```

bar는 선언되지 않는다.

### 함수가 먼저다

그렇다면 함수가 먼절까 변수가 먼절까? 제목을 보면 알겠지만 함수가 먼저다.

```javascript
foo();   // 1
var foo;

function foo() {
  console.log(1);
}

foo = function() {
  console.log(2);
}
```

이 경우 1이 출력되고, 만약 마지막줄에 foo()를 다시 호출한다면 2가 출력된다. 

```javascript
function foo() {
  console.log(1);
}

foo();   // 1

foo = function() {
  console.log(2);
}
```

이런식으로 진행이 된다. 따라서 `var foo;`구문은 무시되어 버린다. `var foo;`가 함수 선언문보다 위지만 함수가 그걸 덮어버린다.

이게 중요한 것인가 싶지만 이런 경우가 발생할 수 있다.

```javascript
foo(); // b

var a = true;
if(a){
  function foo() {console.log(a)};
} else {
  function foo() {console.log(b)};
}
```

블록 스코프가 적용되지 않기 때문에 생각대로 작동하지 않을 수 있다.

### 호이스팅 정리

`var a = 2;`라는 구문은 엔진이 읽을 때 `var a;`와 `a=2;`의  두 구문으로 보고 전자는 컴파일레이션에서, 둘째는 실행단계에서 처리되게 된다.

즉 변수 선언문은 컴파일 단계에서 실행하게 되고 이를 호이스팅이라고 부른다. 스코프의 모든 선언문은 어디서든 제일 처음에 실행되게 된다. 다만 함수 표현식의경우 호이스팅이 되지 않는다.

## 스코프 클로저

클로저의 개념은 모듈패턴과 흡사하다. 크로저는 자바스크립트의 모든 곳에 존재한다. 딱히 새롭게 배우는 패턴이 아니다. 자연스럽게 받아들이면 된다. 위에서 설명한 렉시컬 스코프에 의존해 코드를 작성하면 자연스럽게 발생하게 된다. 그 이유는 클로저의 정의에 있다.

클로저는 함수가 속한 렉시컬 스코프를 기억하여 함수가 렉시컬 스코프 밖에서 실행될 때에도 이 스코프에 접근할 수 있게 하는 기능이다.

즉 원래 스코프를 기억하고, 다른 스코프에서도 원래 스코프에 접근하는 기능이다.

```javascript
function foo() {
  var a = 2;
  function bar () {
    console.log(a);
  }
  bar();
}

foo();
```

[scope](./scope.md)의 내용을 다시 복습해보자면 rhs참조를 통해 함수 a의 값을 bar()에서 이용할 수 있다. 이것은 클로저이기도 하지만 그렇지 않기도 하다. a를 참조하는 bar()는 렉시컬 스코프 규칙에 따라 설명된다. 이는 클로저의 일부다!

현재 렉시컬 스코프는 잘 보이지만 클로저는 애매하다. 이제 클로저를 드러내보자.

```javascript
function foo() {
  var a = 2;
  function bar () {
    console.log(a);
  }
  return bar;
}

var baz = foo();

baz();  //2
```

bar()는 foo()의 렉시컬 스코프에 접근할 수 있고, bar()함수 자체를 반환한다. 이는 bar라는 것을 참조하는 함수 객체를 반환한다.

foo()를 실행하여 반환한 값을 baz에 대입하고 baz를 호출하였다. 이는 당연하게 bar()함수가 실행된다. 그런데 이 경우 bar()는 원래의 스코프인 foo()에서 실행된 것이 아닌 글로벌스코프에서 실행되었다. 다시 한 번 잘 보자. 아까 전 코드는 foo()안에서 bar()가 실행되어 foo()스코프였다. 그런데 지금 실행된 것은 baz()고 스코프는 글로벌 스코프다. 이게 클로저의 핵심이다.

일반적으로 foo()가 실행되면 foo()의 내부 스코프는 가비지콜렉터에 의해 사라진다. 그런데 클로저를 사용하여 bar()가 foo()의 클로저를 계속 사용할 수 있도록 한다. 이 때 bar()는 여전히 해당 스코프에 참조를 가지는데, 그 참조를 클로저라고 부른다.

```javascript
function foo() {
  var a = 2;
  function bar () {
    console.log(a);
  }
  baz(bar);
}

function baz(fn) {
  fn();
}
```

이 경우 fn에 들어간 값은 bar라는 함수를 참조하는 함수객체가 된다. bar()를 호출하면 baz의 스코프 안에서 실행이 되는데 이 때 foo스코프의 a를 클로저를 통해 이용하게 된다.

### 모든 곳의 클로저

```javascript
function wait(message) {
  setTimeout (function timer() {
    console.log( messeage );
  }, 1000 );
}

wait( "Hello" );
```

이 경우를 보자. wait()은 실행 1초 후 내부 스코프는 사라져 버릴 테지만 익명함수가 여전히 클로저를 가진다. 그렇기 때문에 내부함수 timer는 message의 참조를 가지고 있게되고 이게 클로저다.

### 1차정리

자체의 렉시컬 스코프에 접근할 수 있는 함수를 인자로 넘길 때 그 함수가 클로저를 사용하게 된다. 예를들어 타이머, 이벤트 처리, Ajax요청과 같은 활동에서 콜백으로 함수를 넘기면 모두 다 클로저를 사용하게 된다. 흔히 자주 사용하는 비동기적 작업의 콜백함수는 모두 클로저를 가진다.

### 반복문과 클로저

클로저를 가장 잘 설명하는 것은 for 반복문이다.

```javascript
for (var i=1; i<=5; i++){
  setTimeout( function timer() {
    console.log(i);
  }, i*1000 );
}
```

이 코드의 목적은 1, 2, ... 5까지 일초에 한 번씩 출력하는 것이다. 과연 결과가 그렇게 나올까? 당연히 안 된다. 결과는 일 초에 한 번씩 6만 출력한다.

i의 반복이 끝나는 값은 6이다. setTimeout의 콜백함수는 for문이 다 끝나고 나서야 작동한다. 그렇기 때문에 6만 나오게 된다. 시간을 0으로 줘도 6만 나온다.

이 코드를 원하는대로 작동시키려면 무엇이 필요할까?? 생각해볼만한 접근방법은 각각의 i를 잡아두어야 한다는 것이다. i는 반복문이 돌 때마다 값이 바뀌기 때문이다. 값이 변하지 않게 잡아둔다면 이 값을 차례대로 출력할 수 있을 것이다. 여기서 필요한 것이 클로저다. 각각의 i에 대해 스코프를 주어 값을 잡아 클로저로 참조한다면 가능하다.

IIFE를 사용하면 함수가 바로 실행되면서 스코프를 생성한다. IIFE를 사용하여 코드를 수정해보자.

```javascript
for (var i=1; i<=5; i++){
  (function () {
    setTimeout( function timer() {
      console.log(i);
    }, i*1000 );
  })();
}
```

될 것 같은가? 당연하게도 변하지 않는다. 이 경우 각각의 스코프를 가지지만 스코프가 비어있다. 이게 무슨소리라면 IIFE는 아무것도 하지 않는 빈 스코프다. 따라서 자체 변수를 가져야 한다. 아직 이해가 안된다면 아래의 코드를 보자

```javascript
for (var i=1; i<=5; i++){
  (function () {
    var j = i;
    setTimeout( function timer() {
      console.log(j);
    }, j*1000 );
  })();
}
```

이제 해결됐다. IIFE의 스코프에 각각 새로운 변수를 넣고 각각의 timer가 이 변수를 참조하는 클로저를 갖게 하여 정상적으로 작동하게 되었다. 

### 더 나은 반복방법

IIFE를 사용하여 새로운 함수 스코프를 계속 생성했다. 즉 매 반복마다 새로운 스코프가 필요했다. 그렇다면 let을 이용하면 어떨까? 어차피 스코프만 필요하다면 함수보다 let으로 선언하여 스코프를 생성하면 되지 않을까?

```javascript
for (var i=1; i<=5; i++){
  let j = i;
  setTimeout( function timer() {
    console.log(j);
  }, j*1000 );
}
```

이렇게하면 위의 IIFE 코드와 완전히 동일하다. 매번 let변수로 스코프를 만들어 클로저를 가지기 때문에 값을 담아 둘 수 있다. 

let 선언문은 for 반복문에서만 특별하게 작동하는 법칙이 있다. 반복문의 시작부분에 let을 적게되면 한번만 선언되는 것이 아닌 반복하여 선언된다. 코드로 보자. 이해가 바로 된다.

```javascript
for (let i=1; i<=5; i++){
  setTimeout( function timer() {
    console.log(i);
  }, i*1000 );
}
```

이상 let의 편리한 기능으로 모든 문제를 해결했다.