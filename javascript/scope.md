# Scope



특정 장소에 변수를 저장하고 나중에 그 변수를 찾기 위해 정의된 규칙을 스코프라고 한다.

## 컴파일러

자바스크립트는 흔히 동적언어 또는 인터프리터 언어로 분류한다. 하지만 사실 자바스크립트는 컴파일러 언어다. 굉장히 놀랍지만 자바스크립트 엔진은 컴파일러가 하는 일을 처리한다. 전통적인 컴파일러는 소스가 실행되기 전에 3단계를 거치는데 이를 Compilation이라고 한다.

### Tokenizing / Lexing

문자열을 나누어 토큰이라는 조각으로 만드는 과정이다. 예를 들어 `var a = 2;`라는 구문을 보면 이를 var, a, =, 2, ; 이렇게 나누는 것이다. 빈칸의 의미가 있다면 토큰이되고 없다면 토큰이 되지 않는다.

*토크나이징과 렉싱은 미묘한 차이가 있다.* 토큰을 인식할 때 무상태 방식으로 하는지 상태 유지 방직으로 하는지에 따라 구분된다. 이 말이 무엇이냐면 토크나이저가 상태유지파싱 규칙을 적용해 a가 별개의 토큰인지, 다른 토큰의 일부인지를 파악한다면 렉싱이다.

아직은 무슨소린지 잘 모르겠다.

### Parsing

파싱은 나누어진 토큰 배열을 프로그램 문법 구조에 따라 중첩 원소를 갖는 *트리 형태*로 바꾸는 과정이다. 이 트리를 AST(Abstract Syntax Tree)라고 부른다. 

var a = 2;는 먼저 변수선언이라는 최상위 노드에서 시작하고, Identifier와 Assignment Expression이라 부르는 자식노드를 가진다. 전자는 a, 후자는 2라는 값이 들어가게 된다.

### Code-Generation

위에서 만들어진 AST를 실행 코드로 바꾸는 과정이다. AST를 기계어 집합으로 바꿔 실제로 a라는 변수를 생성하고 할당하는 작업이다.

중요한 것은 자바스크립트가 실행되려면 실행 거의 바로 직전에 컴파일 되어 실행된다는 점이다.

## 스코프의 이해

프로그램이 실행 될 때 세 곳의 역할이 중요하다.

* 엔진 : 컴파일레이션의 시작부터 끝까지와, 실행을 책임진다.
* 컴파일러 : 엔진의 친구로, 파싱과 코드 생성을 한다.
* 스코프 : 엔진의 친구로, 선언된 모든 변수 검색 목록을 작성하고 유지한다.

### 검색

`var a = 2;`라는 코드를 코드 생성과정에 들어간다면 컴파일러가 가장 먼저 할 일은 무엇일까? 바로 변수 a가 선언된 적이 있는지를 검색하게 된다. 이에 LHS 검색과 RHS검색이 있다.짐작하겠지만 Left Hand Side, Right Hand Side다. 이는 대입연산의 방향을 의미한다.

쉽게`=`연산자를 기준으로 왼쪽과 오른쪽을 다르게 검사한다는 의미에서 만들어진듯 하다. 엄밀하게는 RHS는 특정 변수의 값만 찾는다. 이에비해 LHS는 변수 컨테이너가 존재하는지를 찾는다. 예를 들어보자.

```javascript
var a = 0;
var b = a;
```

이 경우 첫번째 줄에서 a를 찾을 땐 LHS다. 두번째 줄에서 b를 찾을 때도 LHS다. 마지막으로 두번째 줄에서 a를 찾을 때는 RHS를 사용한다. 변수의 값만 가져오는 것이다.

```javascript
console.log(a);
a = 2;
```

이 경우는 어떨까? 첫번째 줄의 a는 RHS 검색을 수행한다. 두번째 줄의 a는 LHS를 수행한다. 변수의 값과 관계없이 컨테이너에 접근해 2를 대입한다.

```javascript
function foo(a){
  console.log(a);
}

foo(2);
```

1. foo()라는 함수를 호출하면 RHS 참조를 사용한다. 
2. foo()함수가 실행되고 파라미터 자리에 위치한 a라는 변수가 있는지 LHS
3. 2를 대입하고
4. console객체를 RHS검색
5. log메서드가 있는지 확인
6. a를 RHS해서 2라는 값을 받아와 파라미터로 넘겨 log() 호출

의 과정을 거치게 된다.

### 스코프의 중첩

스코프는 Identifier로 변수를 찾기위나 규칙이다. 그런데 이 스코프는 중첩이 가능하다. 안에서 밖으로 엔진이 스코프를 따라 변수를 찾게 된다.

```javascript
function foo(a) {
  console.log(a + b);
}

var b = 2;
foo(2); // 4
```

이 경우 foo()를 호출했을 때 a + b에서 b의 경우 RHS참조가 수행될 것이다. 그러면 foo()라는 함수 스코프 안에서 처리가 불가능하니 그 밖의 스코프에서 변수 b의 RHS참조를 수행한다. 아래 [렉시컬스코프](#렉시컬스코프)에서 조금 더 알아보자.

### LHS와 RHS

두개를 구분하는 이유는 무엇일까? 가장 큰 차이는 변수가 선언되지 않았을 때 서로 다르게 동작하기 때문이다.

```javascript
function foo(a) {
  console.log(a + b);
  b = a;
}

foo(2);
```

b에 대한 RHS검색이 실행되었을 때 검색이 실패하면 선언되지 않은 변수로 ReferenceError를 발생시킨다.

반면 LHS검색을 통해 변수를 찾지 못하고 최상위 층에 도착하면(글로벌 스코프)  글로벌 스코프는 "어 이 변수 없어, 없는데 내가 만들어 줄게!"라고 변수를 생성해서 엔진을 넘겨버린다.

만일 RHS검색 결과 변수는 있는데 그 값을 가지고 불가능한 짓을 하는 경우다. 예를 들어 함수가 아닌 값을 실행시킨다거나 foo(2)();  null이나 undefined인 값을 참조하게 되면 typeError가 발생한다.

## 렉시컬스코프

스코프는 두가지 방식으로 작동한다. 렉시컬 스코프와 동적스코프다.

### 렉스타임

위에서 설명했듯 토크나이징이나 렉싱이라 불리는 작업이 컴파일레이션의 첫 단계다. 렉싱 처리 과정에서 코드를 분석해 상태 유지 파싱의 결과로 생성된 토큰에 의미를 부여한다. 바로 이 개념이 렉시컬 스코프의 어원이다. 무슨소리냐면 렉시컬 스코프는 렉싱타임에 정의되는 스코프기 때문이다.

```javascript
//1단계 (글로벌 스코프)
function foo(a) {
  				
  				  // 2단계 foo()스코프
                    var b = a * 2;

                    function bar(c) {
								 //3단계 bar()스코프
                                      console.log(a,b,c);
                    }

                    bar (b * 3);
}

foo(2);  // 2, 4, 12
```

이해를 돕기위해 indent를 조정했다. 이 코드에는 총 세개의 스코프가 존재하고 각각 주석처리했다. 각각의 함수가 새로운 스코프를 생성했고 중첩되었다. 여기서 알고 가야하는 점은 어떤 함수의 버블도 동시에 두 스코프 안에 존재할 수 없다. 교집합은 없다.

### 검색

이제 엔진이 identifier를 이용해서 변수를 검색할 때 어떻게 찾는지 보자.  3단계 스코프의 console.log()구문을 실행한 뒤 a, b, c를 찾게된다. 검색은 가장 안쪽의 스코프인 bar() 함수의 스코프에서 시작한다. 여기서 a를 찾지 못하면 다음 스코프인 foo() 함수의 스코프로 가고 여기서 찾아 사용한다. b도 마찬가지다. c의경우 bar()함수에서 바로 찾을 수 있다. 만일 foo() 스코프안에서도 c를 정의했다 하더라도 bar에서 먼저 찾을 수 있기 때문에 찾으러 가지 않는다. 지역변수와 전역변수의 개념과 같다. 이를 Shadowing이라고 한다.(안쪽의 변수가 바깥쪽의 변수를 가리는 것)

### eval()과 with

두 기능은 모두 렉시컬 스코프를 런타임 단계에서 수정 할 수 있다.  하지만 with는 명시적으로 사용이 금지되었고, eval()은 핵심 기능만 남기고 금지시켰다. 사용하지 않는걸 권장하니 자세한 것은 설명하지 않고 간단하게만 넘어가자

eval()은 인자로 받느 코드 문자열에 선언문을 넘겨 렉시컬 스코프를 수정할 수 있다.

with문은 넘겨진 객체를 가지고 새로운 렉시컬 스코프를 생성한다.

둘다 사용하지 말자

그 이유는 두 가지 방법은 엔진 컴파일레이션의 최적화 작업을 방해하기 때문이다. 최적화는 렉싱된 코드를 분석하여 모든 변수와 함수 선언문이 어디에 있는지 파악하고 실행 과정에서 검색을 더 빠르게 하는데에 있다. 그러나 이 두 가지 코드를 사용한다면 최적화의 의미가 무색해지기 때문에 사용하지 않는것이 좋다.

## 함수와 블록 스코프

### 함수 스코프 기반의 자바스크립트

자바스크립트는 함수 기반 스코프를 사용한다고 익히 알고있다. 일반적인 다른 언어들과는 다르게 if(){}문과 같은 블럭은 스코프로 취급되지 않으며 오직 함수만이 스코프를 생성한다고 알고있다. 하지만 이는 어느정도 사실이 아니다.

### 함수 스코프

#### 최소권한의 원칙

함수의 스코프로 둘러 싸게되면 그 안의 코드들은 스코프에 감싸져 변수와 함수들이 숨겨진다. 이 숨기는 것은 어디에 좋을까?

여러가지 이유가 있는데 그 중 하나는 소프트웨어 디자인 원칙의 최소 권한의 원칙과 관련이 있다.  소프트웨어를 설계할 때 최소한으로 남기고 나머지는 숨기자는 것이다. 아래의 예제를 보자

```javascript
function doSomething(a) {
  b = a + doSomethingElse(a * 2);
  
  console.log(b * 3);
}

function doSomethingElse(a) {
  return a-1;
}

var b;
doSomething(2);
```

변수 b와 doSomethingElse()는 비공개 부분이어야 한다. doSomething()안에서만 사용되기 때문이다. 그러나 현재는 공개되어있어 위험할 수 있다.  b의 상태가 바뀐다거나, 함수의 내용이 바뀐다면 문제가 생길 수 있다. 그래서 아래와 같이 바꾼다.

```javascript
function doSomething(a) {
  function doSomethingElse(a) {
      return a-1;
  }
  
  var b;
  b = a + doSomethingElse(a * 2);
  console.log(b * 3);
}
doSomething(2);
```

이렇게 말이다. 이제 외부에서 b와 함수에 접근할 수 없어 안전하게 되었다. 함수 스코프의 기본개념은 이렇다. 이런 장점을 사용하기 위해 사용한다.

####충돌회피

숨기는 것이 장점이었지만 또 있다. 같은 이름의 변수의 충돌을 막는다.

```javascript
function foo() {
  function bar(a) {
    i = 3;
    console.log(a + i);
  }
  
  for(var i = 0; i < 10; i++){
    bar(i * 2);
  }
}
foo();
```

이럴 경우 무한루프에 빠진다. 변수 i가 중첩되어 충돌이 되어버렸다. 이런 경우를 방지하기 위해 스코프를 사용한다.

#### 글로벌 네임스페이스

그래서 사용하는 형태가 글로벌 네임스페이스다. 글로벌 스코프의 경우 라이브러리를 불러오는 경우가 많다. 여러 라이브러리를 한 프로그램에 불러오게 되면 충돌의 가능성이 매우 높아진다. 따라서 일반적으로는 객체를 만들 때 고유 이름을 부여하고 네임스페이스로 만든다. 그런 뒤 스코프에 접근하는 것이 아니라 속성형태로 라이브러리의 모든 기능을 이용한다. 제이쿼리를 생각하면 쉽다. 파이썬에서 `import numpy as np`와 같고 $.cookie()와 같은 방식들이다.

#### 모듈관리

더 현대적인 방법으로는 의존성을 관리하는 모듈 접근법이 있다. 이는[호이스팅과 스코프클로저](./hoisting-and-closure.md)의 스코프클로저에서 더 다루도록 하겠다.

​	





