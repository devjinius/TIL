# 암시적 강제변환

암시적 강제변환은 보기에 분명하지 않은(의도하지 않은) 타입 변환을 말한다.

이것 때문에 자바스크립트의 문제가 많은데 이게 무조건 나쁜 것은 아니고 잘 이용하면 좋다. 암시적 변환을 통해 잡동사니나, 불필요한 상세 구현을 줄이는 효과를 가져올 수 있기 때문이다.

예를 들면 이렇다. 아래는 특정 언어와는 무관한 슈도코드다.

```javascript
SomeType x = SomeType(Anotertype (y));   //#1

SomeType a = SomeType (b);   //#2
```

임의 타입 y를 x로 변환할 경우 #1과 같이 중간 변환하는 것이 기존의 엄격한 타입언어들이다. #2번을 보자. 한단계가 줄어들어 단순화되었다. 이 코드는 분명 버그를 양성할 수도 있다. 하지만 코드의 가독성 향상이라는 장점도 가지고 있다. 확실히 위험을 인지하고 피할 수 있다면 가독성 향상이라는 장점은 엄청난 잠재력을 가진다. 중요한 핵심만 명확하게 볼 수 있게 된다.

* [문자열과 숫자](#문자열과-숫자)
* [불리언](#불리언)
* [심벌의 강제변환](#심벌의-강제변환)

## 암시적 강제변환

### 문자열과 숫자

+연산이 가장 대표적이다. +연산(이항연산자)은 두 가지 목적을 가진다. 숫자의 덧셈과 문자열의 연결(concat)이다.

```javascript
var a = "42";
var b = "0";
var c = 42;
var d = 0;

a + b; // "420"
c + d; // 42
```

이 경우 피연산자의 타입이 문자열인지 아닌지에 따라 결정한다고 생각하는것은 잘못 알고 있는 경우다. 틀린건 아니지만 더 복잡하다

```javascript
var a = [1,2];
var b = [3,4];

a + b = "1,23,4";
```

둘다 문자열이 아니지만 문자열로 취급하여 연산되었다. 이는 쉽게 피 연산자중 하나가 객체(배열 포함)라면 ToNumber 추상 연산과정을 거치는데 valueOf()에 원시값 반환이 불가하니 toString()으로 넘어가 "1,2", "3,4"가 반환되게 된다.

어찌되었건 `a + ""`라는 코드는 암시적 강제변환이다. 그렇다면 `String(a)`보다 `a + ""`는 어떻게 다를까? 위에서 얘기했든 valueOf연산과정이 다르다. 

```javascript
var a = {
  valueOf : function() {return 42;},
  toString : function() {return 4;}
}

a + "";   // "42"

String(a);  // "4"
```

일부러 이런짓을 하지는 않겠지만 달라질수있다.

### 불리언

비불리언을 불리언으로 변환하는 경우다. 가장 평범하지만 골칫거리다.

* if()문의 조건식
* for(  ;  ;  )의 두번째 조건식
* while() 의 조건식
* ? : 의 첫번째 조건식
* ||    &&의 *좌측 피연산자*

이 콘텍스트에 불리언이 아닌 값을 사용하면 불리언으로 암시적 강제변환이 된다. 이 때 규칙은 toBoolean 추상연산규칙과 같다.

위에 4경우는 쉬우니까 넘어가고 || &&연산자에 대해 알아보자

|| 와 &&은 보통의 언어와 다르게 작동한다. 자바스크립트와 파이썬 그리고 루비와 같은 언어는 ||의 결과값이 불리언이 아니다.

```javascript
var a = 42;
var b = "abc";
var c = null;

a || b; //42
a && b; //"abc"

c || b; //"abc"
c && b; //null
```

이렇게 된다. 보통의 경우 저 연산결과는 true or false가되는데 이 언어들은 다르다. 

* || 연산자는 결과가 true이면 앞의 피연산자 값을, false면 뒤의 피연산자 값을 반환한다.
* && 연산자는 결과가 true이면 뒤의 피연산자 값을, false면 앞의 피연산자 값을 반환한다.

결곽밧은 언제나 피연산자 값중 하나다. 예를들어 `c && b`의 경우 c는 null이므로 false가 된다. 그렇다고 연산결과가 false는 아니고 자기 자신인 null이된다. 결국에는 암시적 강제변환을 강제하는 코드가 생성된다. 그런데 그래도 아무 이상없이 잘 사용가능하다.

### 심벌의 강제변환

심벌의 경우 암시적 강제변환은 금지된다. 시도만해도 에러가난다.

```javascript
var s1 = Symbol("심볼");
String(s1); // 심볼
s1 + ""; //TypeError
```

