# 암시적 강제변환

암시적 강제변환은 보기에 분명하지 않은(의도하지 않은) 타입 변환을 말한다.

이것 때문에 자바스크립트의 문제가 많은데 이게 무조건 나쁜 것은 아니고 잘 이용하면 좋다. 암시적 변환을 통해 잡동사니나, 불필요한 상세 구현을 줄이는 효과를 가져올 수 있기 때문이다.

예를 들면 이렇다. 아래는 특정 언어와는 무관한 슈도코드다.

```javascript
SomeType x = SomeType(Anotertype (y));   //#1

SomeType a = SomeType (b);   //#2
```

임의 타입 y를 x로 변환할 경우 #1과 같이 중간 변환하는 것이 기존의 엄격한 타입언어들이다. #2번을 보자. 한단계가 줄어들어 단순화되었다. 이 코드는 분명 버그를 양성할 수도 있다. 하지만 코드의 가독성 향상이라는 장점도 가지고 있다. 확실히 위험을 인지하고 피할 수 있다면 가독성 향상이라는 장점은 엄청난 잠재력을 가진다. 중요한 핵심만 명확하게 볼 수 있게 된다.

* [암시적 강제변환](#암시적-강제변환-종류)
  * [문자열과 숫자](#문자열과-숫자)
  * [불리언](#불리언)
  * [심벌의 강제변환](#심벌의-강제변환)
* [동등비교](#동등비교)
  * [느슨한 비교](#loose-equals)
  * [문자열과 숫자비교](#문자열과-숫자비교)
  * [불리언 비교](#불리언-비교)
  * [null, undefined](#null과-undefined)
  * [객체와 원시값 비교](#객체와-원시값-비교)
  * [사례정리](#사례정리)
  * [배열의 비교](#배열의-비교)
* [정리](#정리)
* [[기타] 추상적 관계 비교](#추상적-관계-비교)

## 암시적 강제변환 종류

### 문자열과 숫자

+연산이 가장 대표적이다. +연산(이항연산자)은 두 가지 목적을 가진다. 숫자의 덧셈과 문자열의 연결(concat)이다.

```javascript
var a = "42";
var b = "0";
var c = 42;
var d = 0;

a + b; // "420"
c + d; // 42
```

이 경우 피연산자의 타입이 문자열인지 아닌지에 따라 결정한다고 생각하는것은 잘못 알고 있는 경우다. 틀린건 아니지만 더 복잡하다

```javascript
var a = [1,2];
var b = [3,4];

a + b = "1,23,4";
```

둘다 문자열이 아니지만 문자열로 취급하여 연산되었다. 이는 쉽게 피 연산자중 하나가 객체(배열 포함)라면 ToNumber 추상 연산과정을 거치는데 valueOf()에 원시값 반환이 불가하니 toString()으로 넘어가 "1,2", "3,4"가 반환되게 된다.

어찌되었건 `a + ""`라는 코드는 암시적 강제변환이다. 그렇다면 `String(a)`보다 `a + ""`는 어떻게 다를까? 위에서 얘기했든 valueOf연산과정이 다르다. 

```javascript
var a = {
  valueOf : function() {return 42;},
  toString : function() {return 4;}
}

a + "";   // "42"

String(a);  // "4"
```

일부러 이런짓을 하지는 않겠지만 달라질수있다.

### 불리언

비불리언을 불리언으로 변환하는 경우다. 가장 평범하지만 골칫거리다.

* if()문의 조건식
* for(  ;  ;  )의 두번째 조건식
* while() 의 조건식
* ? : 의 첫번째 조건식
* ||    &&의 *좌측 피연산자*

이 콘텍스트에 불리언이 아닌 값을 사용하면 불리언으로 암시적 강제변환이 된다. 이 때 규칙은 toBoolean 추상연산규칙과 같다.

위에 4경우는 쉬우니까 넘어가고 || &&연산자에 대해 알아보자

|| 와 &&은 보통의 언어와 다르게 작동한다. 자바스크립트와 파이썬 그리고 루비와 같은 언어는 ||의 결과값이 불리언이 아니다.

```javascript
var a = 42;
var b = "abc";
var c = null;

a || b; //42
a && b; //"abc"

c || b; //"abc"
c && b; //null
```

이렇게 된다. 보통의 경우 저 연산결과는 true or false가되는데 이 언어들은 다르다. 

* || 연산자는 결과가 true이면 앞의 피연산자 값을, false면 뒤의 피연산자 값을 반환한다.
* && 연산자는 결과가 true이면 뒤의 피연산자 값을, false면 앞의 피연산자 값을 반환한다.

결곽밧은 언제나 피연산자 값중 하나다. 예를들어 `c && b`의 경우 c는 null이므로 false가 된다. 그렇다고 연산결과가 false는 아니고 자기 자신인 null이된다. 결국에는 암시적 강제변환을 강제하는 코드가 생성된다. 그런데 그래도 아무 이상없이 잘 사용가능하다.

### 심벌의 강제변환

심벌의 경우 암시적 강제변환은 금지된다. 시도만해도 에러가난다.

```javascript
var s1 = Symbol("심볼");
String(s1); // 심볼
s1 + ""; //TypeError
```

## 동등비교

javascript에서는 ==와 ===가 있다. *전자는 값의 동등함을, 후자는 값과 타입의 동등함을 비교한다*고 많이 알고있지만 **틀렸다!!!** 굉장히 놀랍다 나도 그렇게 알고 있었기 때문이다. 

**==는 강제변환을 허용하고, ===는 강제변환을 허용하지 않는다**가 정답이다.

기존에 알고있던 사실로는 후자가 타입도 비교하는구나~ 싶어서 할 일이 많겠군 싶지만 새로 알게된 사실로는 강제변환 과정을 거치니 전자가 더 할 일이 많다는 사실을 알게되었다.

### loose equals

여기에는 강제변환에 관한 몇가지 법칙이 있다.

* 비교할 두 타입이 같다면 값만 비교한다.
* NaN은 그 자신과도 동등하지 않다.(이 부분은 또 나왔다.) [NaN](./type.md)
* +0과 -0은 동등하지 않다.(+에서 수렴하는 0과 -에서 수렴하는 0은 엄연히 다르다)
* 같은 타입의 객체(함수와 배열 포함) 비교는 정확히 같은 레퍼런스가 아니라면 false다.
* != 의 경우 == 연산자의 비교 수행 후 반대 값이다.

위 경우들은 듣고 바로 이해할 수 있다. 자 이제 조금 복잡한 문제를 살펴보자. 뒤에 나올 법칙들을 아래에 정리한다.

-----

* 문자열과 숫자 비교 시 string을 ToNumber()로 변환한 뒤 비교
* 불리언과 비불리언의 비교 시 불리언을 ToNumber()로 변환한 뒤 비교
* null과 undefined는 서로를 비교할 때를 제외하고는 모두 false다.
* 객체와 원시 값의 비교 시 객체를 ToPrimitive()로 변환한 뒤 비교한다

### 문자열과 숫자비교

```javascript
var a = 42;
var b = "42";

a==b // true
```

이 경우 true인것은 안다. 그렇다면 내부적으로 어떻게 강제변환이 일어날까? 위에서 정의했듯 숫자가 아닌 친구를 ToNumber 추상연산을 거친 뒤 비교한다. 따라서 "42"를 42로 변환 후 연산을 수행한다.

### 불리언 비교

```javascript
var a = "42";
var b = true;

a==b; // false
```

흔히 생각하기에 "42"는 truty한 값이다. 따라서 true가 되고 `true == true`비교가되어 true가 나올것이라 생각하지만 답은 false다. 그 이유는 법칙때문이다. 불리언과 비불리언의 비교 시 불리언을 ToNumber()로 변환한 뒤 비교한다는 법칙이 우선한다.

따라서 "42" == true는 "42" == 1 이 되고 문자열과 숫자를 비교하니 문자열을 숫자로 바꿔 `42 == 1`의 비교를 하게된다. 그렇기 때문에 false가 반환된다.

기존에 알고있던 ToBoolean은 동등비교에서 전혀 상관이 없다. 개입조차 하지 않는다. 그렇기 때문에 **==true나 ==false를 사용하면 엄청 헷갈린다. 쓰지말자.**

```javascript
var a = "42";

// 하지말자 (false)
if(a == true);

// 음 좋지않다. (false)
if(a === true);

// 암시적 강제변환(true)
if(a);

// 명시적 강제변환들(true)
if(!!a);
if(Boolean(a))
```

불리언과는 동등비교를 하지 않는것이 정신건강에 좋다.

### null과 undefined

서로 비교할때는 true다. `null == undefined // true` 이런식이다.  순서와 상관없이 true다. 

하지만 그 이외에 어떤 값과 비교해도 false가 나온다. 명심하자. 그렇기 때문에 아래와 같은 깔끔한 코드를 얻을 수도 있다.

```javascript
var a = doSometing();

if (a == null) {
  //.,.,.
}
```

이 코드는 doSomething()이 null이나 undefined를 반환할 때에만 작동하게 된다. 0, false, ""와 같은 값은 안되고 오로지 null이나 undefined만 작동한다. 명시적으로 한답시고 `if(a === undefined || a === null)`과 같이 쓰는 것보다 오히려 깔끔하다.

### 객체와 원시값 비교

객체와 원시 값의 비교 시 객체를 ToPrimitive()로 변환한 뒤 비교한다. ToPrimitive의 경우 valueOf메서드가 있다면 그것을 적용하고 없다면 toString()을 적용한다.

```javascript
var a = 42;
var b = [42];

a == b //true
```

이 경우 42 == b.toString()이 일어나 42 == "42"가 되고 숫자와 문자열비교가 일어나 42 ==42 비교를 통해 true를 반환한다.

ToPrimitive연산이 일어나게 되면 박싱 -> 언박싱과정을 거친다. [네이티브](./native.md) 에서 박싱과 언박싱을 확인하자. 일반 값들은 쉽지만 아래와 같은값은 헷갈릴 수 있다

```javascript
var a = null;
var b = Object(a);
a == b;   // false

var c = undefined;
var d = Object(c);
c == d;   // false

var e = NaN;
var f = Object(e);
e == f; // false
```

우선 null과 undefined는 네이티브가 없다. 따라서 Object()로 박싱되는데 그 과정에서 b와 d는 {}(빈 객체)가 만들어진다. null == {}의 비교가 되고 언박싱되면서 "[Object object]"가 될 것이다.

NaN은 타입이 Number라서 Number객체로 박싱된다만 NaN은 자신과의 동등비교도 같지 않다. false다.

### 사례정리

```javascript
"0" == null; // false
"0" == undefined; // false
"0" == false; // true       **
"0" == NaN; // false
"0" == 0; // true
"0" == ""; // false

false == null; // false
false == undefined; // false
false == NaN; // false
false == 0; // true        **
false == ""; // true       **
false == []; // true       **
false == {}; // false

"" == null; // false
"" == undefined; // false
"" == NaN; // false
"" == 0; // true        **
"" == []; // true       **
"" == {}; // false

0 == null; // false
0 == undefined; // false
0 == NaN; // false
0 == []; // true       **
0 == {}; // false
```

**표시가 되어있는 친구들을 주목할만하다. 아래에 쭉 설명해보겠다.

### 배열의 비교

배열도 객체기 때문에 ToPrimitive가 되고 toString이 실행된다. 따라서 다음과 같은 결과들이 나온다.

```javascript
2 == [2]; //true
"" == [null]; // true
```

위의 경우 는 이해가 바로 되는데 아래는 좀 애매하다. String([null])은 "null"이 아닌가? 하지만 결과는 ""다. 이게 배열의 문제다. 배열을 string으로 바꾸면 문제가 발생한다. 아예막자니 자바스크립트 언어의 다른곳에서 문제가 발생해버린다. 

하지만 어느 누가 배열 전체를 원시값과 동등비교에 놓을지 싶다. 그렇게 만들었다면 그렇게 만든 개발자의 잘못일 것 같다. 배열의 원소가 아닌 배열 전체를 원시값과 비교하려 시도하는것 자체가 잘못되었다... 언어적 결함도 있지만 그런 시도도 사실 잘못되었다고 생각한다.

##정리

위의 사례들을 따져보면 결국에 7가지 경우에 문제가 생긴다.

```javascript
"0" == false; // true
false == 0; // true
false == ""; // true
false == []; // true 
"" == 0; // true
"" == []; // true 
0 == []; // true  
```

이 중 false와 비교한 처음 4가지는 위에서 설명했다. 불리언과 == 연산자를 사용하지 말자. 아무 의미없는 코드다. 피해갈 수 있다.

```javascript
"" == 0; // true
"" == []; // true 
0 == []; // true  
```

이 세가지가 남았는데 배열도 제외하도록 하자. 어느누가 배열과 원시값을 비교하겠나. 저런 시도 자체가 잘못된것이다. 문제는 맨위의 저친구다.

```javascript
function doSometing(a) {
  if(a == ""){
    //....
  }
}
```

이 경우는 보통 a에 문자열을 기대하고 만들었을 것이다. 문자열이 비었다면 함수를 실행할 것이다. 다만 저 a자리에 0이나 []이 들어간다면 문제가 생길 것이다. 원하지 않은 작동이 발생할 것이다.바로 이부분이다. 여기서 부수효과가 발생한다.

그래서 안전하게 사용하면 된다.

* 피 연산자가 [], " ", 0이 될 가능성이 있다면 ==를 사용하지 말자.
* 피 연산자가 true / false일 가능성이 있다면 절대 사용하지 말자.

**== 대신 ===을 사용하면 된다. 동등 비교시 boolean / []  / "", 0이 넘어 올 수 있다면 ===을 사용하면 된다. **

또 하나의 해결방법은 typeof다. [type](./type.md)에서 설명했듯 typeof는  safety guard기능을한다. 따라서 `typeof x == "string" 이나 typeof x ==="string"`과 같은 코드를 사용한다면 완벽하게 부수효과를 막아낼 수 있다.

==비교는 null이나 undefined와 같이 유용하게 이용할 수 있다. 자바스크립트의 암시적 변환은 분명 위험할 수 있다. 하지만 잘 알고 피해간다면 충분히 유용하다. 단지 약간의 위험성을 가지고 있다고해서 파워풀한 기능을 통째로 포기하는 것은 옳지 않다.

## 추상적 관계 비교

<연산이다. ==연산과 비슷하다만 조금 알아둘 점이 있다. 

이 연산은 기본적으로 숫자비교기 때문에 양 쪽 모두 ToNumber로 변경하여 비교한다. 다만 양쪽모두 문자열이라면 서로 문자열의 한글자씩 알파벳 순서로 비교하게 된다.

<= 경우가 좀 눈에 띈다. 이것은 *같거나 작은*이라고 많이 알고잇지만 사실 **<연산 결과의 반대를 반환**한다. 

```javascript
var a = { b: 42 };
var b = { b: 43 };

a < b; // false
a <= b; // true
a >= b; // true
```

와 같은 일이 발생할 수 있다. 객체간의 비교는 레퍼런스가 정확히 일치할때만 true기 때문에 a와 b의 연산은 false다. 그렇기에 true가 반환된다. 
