# Search

검색이다. 어떤 범위 안에서 내가 원하는 것을 검색하는 알고리즘을 말한다.

## Linear Search

순차적인 데이터를 순서대로 1부터 n까지 하나씩 검색해보는 방법이다. 간단하다. 반복문을 돌려서 하나씩 다 검사해보면 된다.

예시로 arr = {2,3,5,7,11,13,17,19}가 있다. 내가 13이란 수 보다 작은 소수의 개수를 알고 싶다면 13의 값을 가지는 arr의 인덱스 값을 알면 될 것이다. 그렇다면 이 index 값을 어떻게 구할까?

뒤에서부터 하나씩 13과 값이 맞는지 대조해보면 가능하다. 이게 선형검색이다. 운이 좋으면 한방에 운이 안좋으면 전체를 다 찾아봐야 할 것이다.

효율성 측면에서 매우 비효율 적이다.

## Binary Search

이진탐색이다. 반 씩 나눠서 처리하는 방법이다. 딱봐도 효율적일 듯 싶다. 간단하다 N/2를 잡고 위인지 아래인지 알아보면 된다. 순차적인 리스트에서 원하는 항목을 찾을 때 매우 효율적이다. 

의사코드는 이렇게 된다.

> 1. min = 0, max = n
> 2. guess = (int) ((min + max) / 2)
> 3. arr[guess] == target 이면 종료
> 4. arr[guess] < target 이면 min = guess+1
> 5. arr[guess] > target 이면 max = guess-1
> 6. 2번 반복

그런데 여기서 놓친점이 있다. 만일 찾고자하는 값인 target이 배열 arr에 없을경우 어떻게 해야 할까?

위에서 arr의 경우 만일 target이 10이라면 10은 arr에서 7 ~ 11 사이에 들어가게 된다. 

​      		2,3,5,7,11,13,17,19 의 경우 

index =   0, 1, 2, 3, 4 , 5 , 6 , 7 이다. 

1. guess = 3이고 4번에 해당되어 min = 4
2. guess = 5이고 6번에 해당되어 max = 4
3. guess = 4이고 6번에 해당되어 max = 3
4. 이 상태일 때 min = 4, max = 3이 된다. 즉 min>max가 되면 값이 배열에 없는 것이다.

따라서 min>max가 되면 값이 없다는 것을 알려주는 코드를 1번 아래에 삽입하여 반복시키면 된다.

### binary search의 개수

bs를 이용했을 때 최대한 검사해야 하는 수의 공식은 2의 log(n)+1이다. +1인 이유는 index가 하나 남을 때도 맞는지 확인해 보아야 하기 때문이다. 

만일 196개의 배열을 가졌다면 

128 < 196 < 256

log 128 < log 196 < log 256

7 +1 < log 196+1 < 8+1 이 된다.