# asymptotic notation

### 알고리즘의 속도

알고리즘의 속도를 분석할 때는 두가지의 조건이 따른다. 

1. 입력값의 크기에 따른 실행시간
2. 실행시간의 성장률(growth rate)

그러나 실행시간은 실행 환경에따라 다르다. 따라서 연상의 실행 횟수를 count하게 된다. 근데 이것도 문제가 있다. 입력 데이터에 따라 실행 횟수가 달라지기 때문이다. 따라서 n번, n^2번, 2n번 이렇게 표현한다. 

그런데 검색의 경우 운이 좋으면 1번, 좋지않으면 n번의 실행결과를 가진다. 실행시마다 또 어떤 조건마다 실행횟수가 다르다. 이걸 하나의 방법으로 비교하는 방법은 없다. 따라서 값을 제한하여 비교하게 된다.

1. 최악의 경우 - Big-O
2. 최선의 경우 - Big-Omega
3. 최악과 최선의 사이 - Big-Theta
4. 평균 (이 경우 값이 커지면 비교하기가 어려워져 사용하지 않는다.)

가장 널리쓰이는 것은 Big-O다. 왜냐하면 컴퓨터 처리 속도에서 아무리 오래걸려도 이거야! 라고 말하는 것이 좀 더 신뢰할 수 있는 방식이기 때문이다.

### 점근적 표기법

```java
int sample(int data[], int n){
  int k = n/2;             // -> 1
  return data[k]		   // -> 1
}                          // -> O(1)
```

함수안의 코드가 실행되는 횟수는 입력값이 어떻던 1번이기에 총 2번 실행하지만 상수의 경우 O(1)로 표현한다. 그 이유는 무한번 반복했을경우 상수는 큰 의미를 가지지 않기 때문이다.

```java
int sum(int data[], int n){
  int sum = 0;
  for(int i=0; i<n; i++){       
    sum = sum + data[i];         // -> n
  }
  return sum
}                                // -> O(n)
```

 사실 for문 안에서 i 초기화하는 것도 n번, i++도 n번 for 안의 코드 n번 이런식으로 C*N번이 실행될 것이다. 그러나 역시 무한의 개념으로 그냥 N이라고만 써주면 된다. 따라서 O(n) 만큼의 실행시간을 가진다.

```java
int search(int n, int data[], int target){  // 순차탐색이다.
  for(int i = 0; i<n; i++){
    if(data[i] == target)
      return i;           //-> 최악의 경우 n번 실행하게 된다.
  }
  return -1
}                         // -> 따라서 O(n)
```

```java
boolean is_distincct(int n, int x[]){
  for(int i = 0; i<n-1; i++)
    for(int j = i+1; j<n; j+1)
      if(x[i] == x[j])
        return false;
  return true;
}  // 전체 조합에 중복된게 있는지 검사하는 알고리즘이다.
// n-1 + n-2 + n-3 + ... + 1이므로 n*(n-1)/2
// n(n-1)/2 = (n^2-n)/2 다. 따라서 Big(n^2)
```

이렇게 간단하게 표현할 수 있다. 이진검색의 경우 2의 logn 인데 아래로 내려가는 수가 2, 3, 4, 건 10이건 무한의 개념에선 그다지 중요하지 않다. log n인지 log n^2인지만 확인하자.



아래 리스트는 자주 보게 되는 점근적 표기법의 함수들이다. 실행시간의 순서에 따라 표기했다.

1. Θ(1)
2. Θ(lgn)
3. Θ(n)
4. Θ(nlgn)
5. Θ(n^2)
6. Θ(n^2lgn)
7. Θ(n^3)
8. Θ(2^n)