# 기초개념

### 템플릿

화면을 구성하는 HTML코드 (화면을 구성하는 틀이다)

### 데코레이터

'@' 이거다(annotation) 이 데코레이터를 붙이면 클래스가 컴포넌트다 라는걸 알려준다.

뒤에 딸려오는 친구들을 메타데이터라고 한다.

### 컴포넌트 생명주기

컴포넌트에는 생명주기가 있고, 이를 인터페이스로 지원한다. 

구현할 경우 메서드 = 이벤트가 된다 *메서드는 화면의 이벤트기 때문*

AfterViewInit이라는 친구는 뷰가 초기화되고 최초 1회만 실행한다. 

### 데이터바인딩

데이터의 변경사항을 뷰와 컴포넌트끼리 관계를 정의하여 자동으로 일치시키는 것. 이 정의를 선언해준다고하여 선언형 프로그래밍이라고 한다.

* 단방향 : 방향은 상관없이 뷰에서 컴포넌트, 컴포넌트에서 뷰로 연결
  * 삽입식
  * 프로퍼티 바인딩
  * 이벤트 바인딩
* 양방향 : NgModel지시자를 이용한다. 사실 프로퍼티바인딩과 이벤트바인딩의 연속사용이다.

#### 삽입식

`{{템플릿 표현식}}` 으로 사용한다.

컴포넌트 클래스의 컨텍스트에 포함된, 속성이나 메서드를 연결한다. 

ex) `{{userName}}` // 컴포넌트의 필드를 뷰에서 사용

메서드의 결과값도 문자열로 치환 후 바인딩이 가능하다 `{{getSomeText()}}` 처럼 말이다.

{{}}안에서 연산도 가능하다. 다만 연산의 실행시간이 오래걸리면 안된다!!

주의할점은 

**1. 템플릿의 표현식의 유효 컨텍스트는 컴포넌트다.** 

**2. 템플릿 표현식에는 side effect가 일어나는 복잡한 수식은 넣지 않는다.**

#### 프로퍼티 바인딩

`[disabled]="템플릿 표현식" // DOM이 소유한 프로퍼티를 []로 바인딩`

중요한 것은 프로퍼티의 경우 문자열만 바인딩 되는 것이아님 `<h1 class="test" [class.test] = "isTest">` 처럼도 사용도 가능하다.

여러 클래스의 경우  NgClass나 NgStyle 지시자를 사용하는 것이 적합하다.

#### 이벤트 바인딩

`(click)="템플릿 표현식"` 

DOM의 이벤트 핸들러로 컴포넌트의 메서드를 활용한다. 

*삽입식과는 다르게 side effect를 일으키는 표현식도 포함 가능하다.*

### 서비스

컴포넌트는 view단을 움직이는 스크립트 로직 역할이다.  서비스는 비즈니스 로직을 담는다. *(서비스는 MVC에서 Controller역할인건가..? 이 부분은 아직 잘 모르겠다.)*

서비스는 싱글톤 디자인 패턴을 가지며, 모듈에 의존성주입 패턴으로 연결한다. 

컴포넌트끼리 데이터를 공유할 때에는 서비스를 거친다. 예를들면 한 service를 각각의 컴포넌트가 임포트해서 서비스의 값을 서로 사용하고 변경한다. 그렇게 되면 다른 컴포넌트도 변경된 값을 사용하게 된다.

### directive

템플릿을 동적으로 만드는 요소다. 쉽게 생각해서 jstl의 기능 + Jquery의 기능이라고 보자. 

사실 컴포넌트도 지시자라고 한다. 서로 다른 점은 컴포넌트는 하위 컴포넌트를 가질 수 있다. 하지만 지시자는 컴포넌트를 가질 수 없다. 조금 다르게 컴포넌트가 하위 지시자를 가질 수도 있다.

#### 구조지시자

쉽게 생각해서 jstl이다. dom의 구조를 바꿀때 사용한다. *ngIf, *ngFor, *ngSwitch 같은 지시자가 있다.
*ngFor의 경우 인덱스를 사용하고자 한다면 ` *ngFor="let str of text; let idx = index"`로 사용 가능하다. 

더미태그를 사용하기 싫다면 ng-container를 사용한다. `<ng-container *ngIf="isTrue()">` 이렇게 사용하면 DOM에 추가하지 않으면서 구조 지시자를 사용할 수 잇다.

#### 속성지시자

dom의 속성을 관리할 때 사용한다.

```typescript 
<div [ngClass] = "myObj">

myObj = {'test-class' : true, 'ur-class': 0, test:true};
```

위와 같은 경우라면 true의 key만 바인딩된다.

### 파이프

값을 가공해서 보여줄 때 사용한다. 기본적으로 포맷의 기능이다. 다만 연산도 가능하다. 

ex) 한국어(ko)를 보여줄 경우

```typescript
{{lang | langSelectorBtn}} // 이렇게 사용

// 아래는 langSelectorBtn구현 코드
transform(lang): any{

    return ${lang.name} (${lang.code});
```

 langSelectorBtn은 파이프 이름이다. 파이프는 인터페이스이며 transform메서드 하나만 구현하면 된다. 

기본 지원되는 파이프도 있다(uppercase, lowercase, currency, percent등등)

좋은 점은 연속사용도 가능하다. `{{myName | upperCase | honor}}` 이런 식으로 사용하게 되면 myName이 upperCase pipe에 들어가고 그 결과값이 honor pipe의 입력값으로 들어가 최종 값이 나오게 된다.

### Module

앵귤러의 컴포넌트, 파이프, 서비스등을 묶은 하나의 단위다. 루트 모듈에 사용하는 메타데이터를 적는다.

#### bootstrap

애플리케이션을 최초 실행할 때 브라우저에서 진행되는 과정이다. 이를 Module에 의존성주입한다. 여기 선언된 컴포넌트는 index.html을 요청 받았을 처음에 실행한다.

#### declarations

모든 컴포넌트와 파이프를 Module에 배열로 선언한다. 

#### imports

모든 모듈을 배열로 선언한다.

#### providers

모든 서비스의 의존관계를 배열로 선언한다.