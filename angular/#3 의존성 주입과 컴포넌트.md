## 의존성 주입

서비스를 싱글턴으로 만든 뒤 의존성을 주입한다. 이는 전형적인 객체지향의 디자인 패턴인데, 앵귤러를 통해 알아보자.

### 서비스

서비스에 대해 다시 한번 더 정리해 보자면 서비스는 Spring에서 ServiceImp + VO의 역할이다. 기능이 두 가지 인데 순수한 비즈니스 로직 + 공유되는 값이다. 즉 컴포넌트는 순수하게 뷰의 생성과, 뷰와의 상호 작용을 관리한다. 따라서 컴포넌트에서 뷰와 연관이 없거나 여러 컴포넌트에 산재한 공통 로직을 분리하여 서비스에 담으면 된다. 서비스의 등장으로 컴포넌트는 뷰와의 상호작용만을 담당하게 된다.

어떤 비즈니스 로직(예를 들어 a와 b를 단순히 더한다고 치자.)을 컴포넌트에서 사용해도 작동에는 아무 상관이 없다. 하지만 만약 이 로직에 변경이 필요하다면 문제는 두 가지가 발생한다. 이는 두 가지 기능을 하기 때문이다. 비즈니스 로직 + 공유되는 값의 특성처럼 컴포넌트에서 뷰와 상관없는 비즈니스로직을 변경해야하고, 공유되기 때문에 사용되는 모든 곳에서 변경이 필요하다. 즉 중복이 발생하게 된다. 따라서 서비스를 이용해서 이를 해결한다.

###version 1

우선 MySpecialLoggerService라는 서비스를 만든 뒤 이를 컴포넌트에서 import 해서 사용한다.

```typescript
import {MySpecialLoggerService} from './my-special-logger.service';
{...}

@Component({...})
export class AppComponent {
	logLevel: LogLevel = LogLevel.INFO;
     logger: MySpecialLoggerService;

     constructor() {
		this.logger = new MySpecialLoggerService(this.logLevel);
	}
}
```

이런식으로 import해온 뒤, logger의 타입만 선언하고(타입스크립트), 생성자에서 객체를 생성하여 서비스를 이용한다. 예제에서는 AppComponent와 MTZComponent에서 모두 import한 뒤 객체를 생성하여 서비스를 이용했다. 즉 여러 컴포넌트에서 같은 기능을 서비스를 이용하여 사용했다.

### 싱글턴

version#1에서 여러 기능을 담은 서비스를 각자의 컴포넌트에서 생성하여 사용했다. 각자의 컴포넌트에서 구현하지 않았기 때문에 중복없이 동일한 로직의 기능을 사용할 수 있게 되었다. 마찬가지로 기능이 변경되더라도 서비스만 변경해주면 모든 변경사항이 동일하게 반영되게 된다. 그러나 여기에는 문제가 숨어있다. 바로 각각의 컴포넌트에서 인스턴스를 생성한다는 것이다.

이 예제에서는 로그레벨을 파라미터로 받아서 사용한다(LogLevel.INFO). 만일 이 로그레벨을 한 곳에서 변경하면 전역적으로 모든 곳에서 변경되어야 한다고 생각해보자. 즉 어떤 상태가 변경되고 이 것이 전역에 영향을 미치는 경우다. version#1처럼 각각의 인스턴스를 생성한 뒤 로그레벨을 수정한다면 이는 자신의 컴포넌트에서만 영향을 미치게 된다. 다른 인스턴스에는 영향을 미치지 못하는 것이다.

이 문제는 인스턴스를 하나만 생성한 뒤 이를 공유한다면 해결할 수 있다. 서비스를 사용하는 최상위 루트에 서비스를 생성한 뒤 다른 컴포넌트를 전달하는 것이다.

이렇게 인스턴스를 하나만 생성하는 디자인을 싱글턴 디자인이라고 한다.

### version 2

상위 컴포넌트에서의 템플릿 파일입니다.

```html
<h1>{{title}}</h1>
<mpl-mouse-track-zone [logger]="logger"></mpl-mouse-track-zone>
```

프로퍼티 바인딩을 통해 템플릿에서 logger를 넘겼다. 자식 logger 속성에 부모 logger를 넘겼다. =을 기준으로 좌변이 자식 logger, 우변이 부모 logger다. 이제 자식 컴포넌트에서 @input으로 받으면 된다.

```typescript
import {component, OnInit, Input} from '@angular/core';

@Component({...})
export class MouseTrackZoneComponent implements OnInit {
	@Input private logger: MySpecialLoggerService;

     constructor() {
		//this.logger = new MySpecialLoggerService(this.logLevel);
	}
}
```

생성자의 인스턴스 생성 코드를 제거하고, logLevel을 없앴다. 그 뒤 @Input데코레이터를 붙여 logger를 받는다. 생성자가 필요없어지게 되어 생성자를 지우고, 파라미터인 logLevel도 없앴다. logger속성은 바인딩된 값을 받기때문에 @Input 데코레이터를 붙였다. 인스턴스를 생성하지 않고 넘겨받은 것이다.

### 새로운 문제와 의존성 주입

version 2로 싱글턴을 사용하여 인스턴스를 한 번만 생성하고,  그 인스턴스를 넘겨 중복의 문제를 해결했습니다. 그래서 전역적으로 다른 컴포넌트에서도 같은 상태의 인스턴스를 사용할 수 있게도 되었습니다.

하지만 아직도 문제는 남아있습니다. 만약 수십, 수백개의 컴포넌트에 같은 인스턴스를 사용한다고 가정합시다. 그렇다면 일일이 모든 컴포넌트에 인스턴스를 전달하여야 합니다. 이는 여간 불편한 것이 아닙니다. 만약 Service의 기능이 변경되어 생성자 파라미터가 추가도니다면 인스턴스를 생성하는 (현재는 AppComponent) 컴포넌트의 코드도 수정해야 합니다.  인스턴스를 생성하는 AppComponent가 Service를 의존하기 때문에 Service의 변경사항은 Component에도 영향을 주게 됩니다. 이 문제는 전통적인 소프트웨어 개발의 문제로, 의존성주입(DI)로 해결할 수 있습니다.

의존성 주입 패턴을 이용하게 되면 가장 큰 차이점은 바로 **인스턴스를 생성하는 것이 아닌 주입받는것이 됩니다.** 인스턴스가 필요한 시점에 인스턴스를 어떻게 생성하는지(생성자가 어떻게 돌아가는지) 몰라도 그냥 만들어진 인스턴스를 주입받으면 됩니다. 객체지향의 특징이 잘 녹아 들어갔습니다.

이에 앵귤러는 의존성 주입기를 내장하고 있으며 컴포넌트, 서비스등을 주입기를 통하여 제공할 수 있습니다. 따로 싱글턴 인스턴스를 직접 관리하지 않아도 됩니다.

### version 3

의존성 주입기능을 사용하려면 해야할 첫번째 작업은 NgModule의 메타데이터에 의존성을 주입받을 대상을 선언합니다. 즉 의존 정보를 NgModule의 providers에 명시해야 합니다.

```typescript
@NgModule({
  declarations: [...],
  imports: [...],
  providers: [MySpecialLoggerService],
  ...
})
```

다음으론 Service의 인스턴스를 공유하기 위하여 수정했던 코드도 원상복귀합니다.

* NgModule에 의존정보 명시
* 템플릿 프로퍼티 바인딩 삭제
* 인스턴스를 받는 컴포넌트의 input 데코레이터 삭제
* 컴포넌트(부모와 자식 모두) logger속성 삭제 후 컴포넌트 생성자의 매개변수로 logger 선언

마지막 내용은 아래와 같습니다.

```typescript
constructor(private logger: MySpecialLoggerService){}
```

위와 같이 변경해줍니다. 생성자의 매개변수로 선언한 이유는 앵귤러 의존성 주입기가 컴포넌트(클래스)를 생성할 때 생성자의 인자로 서비스를 주입해 주기 때문입니다. 즉 의존성 주입기가 의존성을 주입해주는 통로가 클래스 생성자입니다.