## 웹서비스

웹서비스는 무엇인가를 요청하고 응답받는 구조다.커피숍에서 커피를 주문(요청)하면 커피를 만들어 응답합니다. 똑같이 구글에 검색어를 입력하여 요청하면 그 결과인 HTML을 응답합니다.

브라우저가 이해할 수 있는 형식은 html, css, js입니다. 이 형식으로 파일을 만들면 웹 브라우저가 실행을 시켜준다.

HTML, CSS는 컴퓨터 프로그래밍 언어는 아닙니다. 컴퓨터 프로그래밍언어는 '저장, 연산'하는 언어입니다. 저장이나 연산과정이 없는 위 두언어는 마크업언어 입니다.

마크업 == 구조화 ==> 공부하다 중요한 내용에 밑줄을 긋는 것
ex)이름강진성나이25살학과경영정보현재재학중.... 이걸 엔터, 띄어쓰기, 색, 강조 등등 하는것이 구조화

CSS는 구조 / 디자인을 분리하는 언어. 결국에 구조를 위함임. 

프론트엔드: 눈에 보이는 부분 - html, css백엔드: 눈에 안보이는 부분 - ruby

### 언어-프레임워크의 관계

카페 주인이 커피를 쉽게 만들고 싶으면 프랜차이즈 가맹점에 가입을 합니다. 즉 내 가게를 처음부터 만드는게 아니라 기존의 잘 되는 틀을 가져다 쓰자. 이게 바로 프레임워크다.
정해진 규칙만 지키면 빠르게 커피(웹서비스)를 만들 수 있습니다. 즉 효율적입니다.우리는 레일즈라는 프레임워크를 사용할 것이고 소수의 인원으로 서비스만들기 좋습니다.

## OOP

객체 - 현실에 존재하는 무언가 / 사물 / 대상지향 - 목표 / 가리키는 것입니다.

프로그래밍 - 컴퓨터 프로그램을 작성한다.=> 현실의 무언가를 컴퓨터 프로그램으로 만드는 것

대상은 정보와 행위를 가집니다. (사람 / 이름, 나이, 성별 / 달린다 걷는다 마신다) 이는 각각 변수와 함수에 대응됩니다.

object를 만드는 이유는 정보/행위를 가진 현실을 재창조하는 것.

100m 경주에서 각각의 사람은 정보가 다릅니다. 각자 다들 다르지만 같은 정보를 가지고 같은 행위를 가집니다.
이름: 도도, 나이: 20세, 성별: 남자, 달리기/걷기/마시기 가능 
이름: 바우, 나이: 21세, 성별: 여자, 달리기/걷기/마시기 가능
이름: 아루루, 나이: 22세, 성별: 남자, 달리기/걷기/마시기 가능
이런식으로 모두 프로그래밍을 할 필요는 없다.

객체지향 프로그래밍을 통해 재활용 / 중복의 제거라는 효과를 얻게 됩니다.

### 다른 변수, 같은 함수, 다른결과

클래스와 인스턴스사람    -   사람 1(도도), 사람 2(바우)
각각은 정보가 다르지만 하는 행위는 같습니다. 다만 같은 행동을 한다고해서 같은 결과가 나오진 않습니다.
사람들은 모두 달리지만 달리기 기록은 모두 다른 것처럼 말입니다. 즉 다른 변수, 같은 함수, 다른 결과를 가집니다.

### 클래스와 인스턴스

클래스.new() => 인스턴스 생성 코드입니다.

### 생성자

```ruby
def initialize(name)
  @name = name
end
```

### 인스턴스 변수(@)

인스턴스 안에 소속된 메서드 안에서만 활용 가능한 변수입니다.

### 클래스 변수(@@)

스태틱 변수와 비슷한 개념. 클래스 안 전체에서 사용 가능한 변수ex) Person.number_of_instance

### 클래스 메서드

```ruby
def self.number_of_instance
  puts "a......"
end
```

클래스 메서드에는 self를 붙여주어야 합니다.

추가로 self말고 클래스명을 써도 가능합니다.

```ruby
class Dog
  class << self
    def another_class_method
      :still_another_way
    end
  end
end
```

이런식의 self의 상속을 이용한 방법도 가능합니다. 다만 이 방법은 약간 다릅니다. 싱글턴 인스턴스를 생성하는 방식입니다. eigenclasses라고 부릅니다.

## 상속

이전의 클래스를 이용해서 재활용 / 중복을 제거하는 방법입니다.
kick, shot, catch는 run + a 의 기능입니다. 즉 Person.run을 물려받아서 자신의 기능을 추가하는 것입니다.

`< Person` 으로 작성하여 상속받습니다.
상속받은 메서드를 덮어쓸 수 있고(상속을 거부), super를 통해 기능을 추가가 가능합니다.

루비의 경우 다중상속은 불가능합니다. 즉 두 개 이상의 상속은 불가능합니다. 믹스인을 사용하여 기능을 구현합니다.

```ruby
class Person
    @@people_count = 0				# 생성되는 인스턴스 수를 체크하기 위한 클래스 변수
    
    def initialize(name)			# 생성자
        @name = name
        @@people_count += 1
    end
    
    def run									# 인스턴스 변수
        puts "#{@name} is running"			   # 문자열 보간법(string interpolation)을 사용하여 변수와 함께 출력
    end

    def drink
        puts "#{@name}가 물을 마십니다!"
    end
    
    def self.number_of_instance					# 클래스 메서드 생성.
        puts "#{@@people_count}만큼 현재 인스턴스가 생성되었습니다."
    end
end

class SoccerMan < Person						# 상속
    
    def run
        puts "#{@name} 이 상대 수비수를 제칩니다."
        super									# overriding 입니다. super를 호출하여 부모 메서드를 사용할 수 있습니다.
    end

    def kick
        puts "#{@name}선수가 공을 찼습니다."        
    end
end


ronaldo = SoccerMan.new("호날두");
ronaldo.run
ronaldo.kick
```

예제를 총 정리한 코드입니다.

### 클래스 메서드에서의 인스턴스 변수 사용

당연히 안됩니다. 다만 테스트해본 결과 에러는 나지 않으며 변수부분이 empty string 처리되어 출력됩니다.