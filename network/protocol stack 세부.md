# protocol stack

###큰 흐름

애플리케이션 레이어에서 요청을 받으면 OS는 프로토콜 스택에서 작업을 실행한다. 프로토콜 스택의 윗부분에는 TCP / UDP가 있으며 둘 다 데이터 송수신을 담당합니다. TCP는 일반적인 데이털르 송수신하는 것이며 UDP는 DNS서버와 같이 짧은 제어용 데이터를 송수신할 때 사용합니다.

그 뒤 IP 프로토콜을 이용하여 송 수신을 제어하고 이를 패킷으로 나누어 운반하게 됩니다. 패킷을 통신 상대까지 훈반하는 것이 IP의 역할입니다. IP안에서는 ICMP와 ARP라는 프로토콜을 다룹니다. 전자는 패킷을 운반할 때 발생하는 오류를 통지하거나 제어할때, 후자는 MAC주소를 조사할 때 사용합니다.

그 아래에는 LAN 드라이버가 있습니다. LAN 어댑터의 하드웨어를 제어합니다. 

### 프로토콜 스택과 소켓

프로토콜 스택은 내부에 제어정보를 기록하는 메모리 영역을 가지며 통신동작을 제어하기 위한 제어 정보를 기록합니다. 상대의 IP주소, 포트번호, 진행상태등을 기록합니다. 소켓의 경우 실체는 사실 없지만 이 제어정보를 소켓으로 볼 수 있습니다. 즉 파이프의 입구인 소켓은 특정한 실체는 없지만 이러한 제어정보들을 이야기합니다. cmd창에서 `netstat -ano`를 입력하면 나오는 정보들이 소켓입니다. PID(processID), protocol, ip주소, 상태와 같은 정보들을 저장합니다.

### socket & descriptor

`<디스크립터> = socket(<IPv4>, <TCP사용>, ...);`

이 부분이다. 소켓을 만드는 단계입니다. 소켓을 만든 뒤 커넥트하게 됩니다. 소켓을 만든다는 것은 프로토콜 스택이 메모리 영역을 확보하는 것입니다. 메모리를 확보하여 소켓을 만들고 이를 디스크립터를 반환하여 구분하게됩니다. 이후 프로토콜 스택에 어떤 동작을 의뢰할 때 디스크립터를 이용하게 됩니다.

### connect

만든 소켓으로 connect를 호출합니다. 그러면 프로토콜 스택은 클라이언트측 소켓을 서버측 소켓에 접속합니다. 

`connect(<디스크립터>, <서버의 IP주소와 포트번호>, ...);`

이 부분입니다. 접속은 서로의 제어 정보를 주고받아 데이터 송 수신이 가능한 상태로 만드는 것입니다. 클라이언트 측의 ip주소나 포트번호를 알리는 것이 그 예입니다. 구체적으로는 송 수신시 데이터를 일시적으로 저장하는 메모리 영역이 필요한데 이를 버퍼메모리라고 합니다. 이 버퍼메모리를 확보하는 것이 접속한다는 의미이기도 합니다.

####제어정보

서로의 제어 정보를 주고 받는다고 했는데 이 제어정보에는 크게 두 종류가 있습니다. 하나는 서로 연락을 절충하기 위해 주고받는 제어 정보입니다. 이는 보통 TCP헤더라고 부릅니다. 포트번호, 시퀀스번호, ACK, 컨트롤 비트 등이 포함됩니다. 다음으로는 소켓에 기록되는 정보입니다. 애플리케이션에서 통지된 정보, 상대로부터 받은 정보등이 수시로 진행됩니다. 또한 진행상황 등도 실시간으로 기록됩니다. 이 소켓 정보는 상대측에서 볼 수는 없습니다. 헤더의 경우 서로가 주고받지만 소켓정보는 OS마다 다르기 때문에 주고받지 않고 서로 모릅니다.

* 헤더에 기입되는 정보
* 소켓에 기록되는 정보

#### 접속동작의 실체

애플리케이션 레이어에서 connect를 실행하게되면 프로토콜 스택에게 의뢰하여 헤더를 만들게 됩니다. TCP 헤더에 있어 중요한 것은 송신처와 수신처의 포트번호입니다. 

그 후 SYN이라는 컨트롤 비트를 1로 만든 뒤 TCP헤더를 다 만들고 이를 IP에게 건네주게 됩니다. 그렇게 넘어간 헤더는 서버측 TCP까지 도달하고  수신처의 포트번호를 조사해 소켓을 찾아 이에 알려주게 됩니다. 클라이언트와 마찬가지로 서버측에서도 헤더를 만들고 ACK를 1로 만들어 응답합니다. 이는 패킷을 받았다는 것을 알리는 정보입니다. 새로만든 응답 TCP헤더를 IP에게 전달하여 같은 과정으로 응답하게 됩니다.

돌아온 패킷은 클라이언트 TCP까지 도달하게 되고 TCP헤더를 조사하여 접속이 성공했는지 확인합니다. SYN이 1이면 접속 성공이므로 서버의 IP주소나 포트번호등과 함께 관련 정보를 기록하고 마지막으로 잘 받았다는 표시로 ACK비트를 1로 만든 패킷(방금받은 그 패킷)의 TCP헤더를 반송합니다.  이 과정으로 접속이 완료됩니다. 이제 소켓을 찾아 파이프를 만든 것이고 데이터를 송수신하기위한 준비가 끝나게 됩니다. 단순히 한번의 통신이 아닌 세번의 통신을 거쳐 접속 후 정보를 주고받게 됩니다. 이는 close를 호출하기 전 까지 연결이 지속됩니다.

### 데이터 송수신

접속을 완료하였으면 이제 데이터를 송신하게 됩니다. 이 때 write()를 호출하여 데이터를 프로토콜 스택에 전달합니다. 여기서 프로토콜 스택은 데이터의 내용에 무엇이 쓰였는지 알지 못합니다. 단순한 데이터로만 인식합니다. 이를 바로 송신하는 것이 아니라 버퍼 메모리에 저장한 뒤 다음 데이터를 애플리케이션이 보내길 기다립니다.

그 이유는 송신을 의뢰할 때 애플리케이션에서 보내주는 데이터의 길이는 모두 다릅니다. 데이터를 한꺼번에 보낼 수도, 혹은 세분화 할 수도 있습니다. 그렇기 때문에 데이터를 어느정도 저장하고 기다렸다가 송수신을 하게 됩니다. 그럼 어느정도로 데이터를 저장하느냐가 문제인데 이는 os마다 다르지만 대략적인 메커니즘만 알아보겠습니다.

판단요소는 두가지가 있습니다.

* 한 패킷에 저장할 수 있는 데이터의 크기
* 타이밍

먼저 데이터의 크기입니다. 프로토콜 스택은 MTU(Maximum Transmission Unit)라는 파라미터를 바탕으로 판단합니다. 이는 패킷이 운반하는 최대의 길이로 이더넷에서 보통 1500바이트가 됩니다. 여기에는 각종 헤더 + 데이터가 합쳐집니다. 즉 MTU = Header + Data의 최대길이입니다. MTU-Header = Data의 최대길이가 되는데 이를 MSS(Maximum Segment 
Size)라고 합니다. 프로토콜 스택은 애플리케이션에서 받은 데이터가 MSS와 가깝게 되거나 초과하게 되면 송신동작을 실시하게 됩니다.

다음으로는 타이밍입니다. 만일 애플리케이션의 송신속도가 느려지는 경우 위에서처럼 MSS만을 기준으로 데이터를 저장하고 송신하면 너무 느려질 수 있습니다. 따라서 내부에 타이머를 두고 일정 시간이 지나면 그냥 전송하게 만듭니다.

이 두 요소는 서로 상반되는 장점을 가집니다. 버퍼에 머무는 시간을 늘리며 데이터를 크게크게 보내면 네트워크 이용 효율이 높아지지만 송신동작이 느려집니다. 그 반대로 데이터를 바로바로 보내면 송신동작은 빠르지만 효율이 나쁩니다. 그렇기 때문에 OS의 종류나 버전에 따라 조금씩 달라지게 됩니다.

####데이터가 큰 경우

폼을 이용해 수정이나 등록과 같은 작업을 하는 경우 보내야 하는 데이터의 크기가 MSS를 초과하게 됩니다. 그럴 경우에는 우선 버퍼에 기다릴 필요는 없습니다. 이미 MSS를 넘어갔기 때문입니다. 그럼 한 번에 보내는 양은 MSS고, 데이터의 크기는 MSS를 이미 초과했기 때문에 한 번에 보낼 수 없습니다. 이 경우 데이터를 분할하게 됩니다.데이터를 분할한 뒤 각각 헤더를 부가하여 IP에 건네주게 됩니다.

#### ACK

이제 데이터가 서버로 송신되는데 이게 끝이아닙니다. TCP는 송신한 데이터가 상대에게 올바르게 도착했는지 확인하는 기능이 있습니다. 

개념부터 설명해보겠습니다.

송신측은 데이터를 분할해서 넘긴다고 했습니다. 그럼 그 데이터들의 순서를 나타내야 합니다. 그래야 수신측에서 순서대로 다시 합칠 수 있기 때문입니다. 이를 시퀀스 번호라고 합니다. 그런데 이 번호는 1번, 2번처럼 되어있지 않습니다. 어느 바이트부터 시작하는지를 나타냅니다. 만일 5000바이트의 데이터를 3개의 패킷으로 나누었다고 생각하면 1 ~ 2000, 2001 ~ 4000, 4001 ~ 5000이렇게 세 패킷으로 나뉠 것입니다. 이 경우 1, 2001, 4001이 시퀀스 번호가 됩니다. 

수신 측에서는 패킷에서 헤더만큼의 길이를 빼서 데이터의 크기를 측정할 수 있습니다. 그래서 시퀀스 번호부터 데이터의 크기만큼을 더해 다음 시퀀스 번호를 알 수 있게 됩니다. 즉 첫 패킷에서 시퀀스 번호 + 데이터 크기 (1 + 2000) = 2001이 다음 시퀀스 번호임을 알 수 있게 됩니다. 이 다음 시퀀스번호를 ACK번호라고 합니다. 이렇게 여러 데이터를 합쳐서 제일 큰 ACK번호를 송신측에게 통보합니다. 그러면 송신측은 ACK번호를 받게 되고 나의 마지막 데이터보다 1 큰값이 오면 데이터가 정상적으로 보내졌음을 알 수 있게 됩니다. 이를 수신 확인 응답과정이라고 합니다.

그런데 실제로는 해킹의 위험때문에 시퀀스 번호를 1부터 시작하지 않고 난수의 초기값으로 설정합니다. 난수로 설정하면 송신측은 초기값이 뭔지 모르기 때문에 SYN이라는 제어비트를 이용하여 초기값을 통지하게 됩니다.

이를 이제 송수신 모두에게 적용시켜 보겠습니다. 수신측도 응답하는 데이터가 잘 갔는지 확인해야 하기 때문에 서로 확인하게 됩니다. 왼쪽이 서버, 오른쪽이 클라이언트라고 한다면

<==== 클라이언트 측 시퀀스번호 초기값 ====    		(1)

==== 서버측 시퀀스 번호 초기값 + ACK번호 ====>	(2)

<==== 클라이언트 측 ACK번호 ====					(2-1)



<==== 클라이언트 측 시퀀스 번호 ====		  		(3)

==== 서버측 ACK 번호 ====>						(4)


==== 서버측 시퀀스 번호 ====>						(5)

<==== 클라이언트 측 ACK 번호 ====					(6)

(1)에서 먼저 시퀀스 초기값을 보냅니다. (2)에서는 초기값을 잘 받았다고 ACK번호를 보내면서 동시에 서버측 시퀀스 번호 초기값을 같이 통지합니다. 그럼 통지받은 클라이언트도 잘 받았다고 ACK번호를 서버에게 보내줍니다. 이 과정이 (2-1)입니다. 2-1까지의 과정이 접속동작입니다(connect) 총 세번의 통신이 이루어져 Threeway HandShake라고 부릅니다.

(3)에서는 이제 시퀀스번호와 데이터를 같이 보냅니다. 이 부분이 데이터 송수신 동작입니다. 이를 잘 받았다면 서버는 (4)에서 ACK번호를 보냅니다. 서버에서 데이터를 보낼때는 5 ~6처럼 반대의 과정을 거칩니다.

TCP는 이렇게 상대가 데이터를 받은 것을 확인합니다. 패킷을 버퍼에 저장해두고 ACK번호가 돌아오지 않으면 패킷을 다시 보내게 됩니다. 이렇게 패킷단위로 보관하기 때문에 그 부분만 ACK를 확인하여 다시 보내면 됩니다. 

#### 타임아웃 값

ACK를 대기하는 시간을 타임아웃 값이라고 합니다.  이 타임아웃값은 너무 길어도 문제, 너무 짧아도 문제가 됩니다. 그런데 적정 값을 찾기 굉장히 어렵습니다. 네트워크 환경에 따라 다르기 때문입니다. 환경이 빠르다면 금방 ACK가 돌아오지만 환경이 변한다면 적절한 값이 무의미해집니다.  따라서 동적으로 이 시간을 변경하는 방법을 취합니다. ACK번호가 돌아오는 시간을 기준으로 대기 시간을 판단하게 됩니다. 보통의 최소값은 0.5초에서 1초로 설정되며 통신 과정의 응답시간에 따라 유동적으로 움직이게 설정합니다.

#### 윈도우 제어방식

핑퐁방식과 윈도우 제어방식이 있다. 이는 동기와 비동기 방식으로 생각하면 된다. 동기화 방식은 핑퐁이며 비동기화 방식은 윈도우 제어방식이다. 패킷이 여러개라서 동기화방식으로 하나씩 넘기고 ACK를 받으면 너무 느리다. 비동기화 방식은 데이터를 마구 송신한 뒤 수신확인응답과정을 따로 처리하게 된다. 그런데 이 과정에서 문제가 생길 수 있다.  수신측에서 처리할 수 있는 용량 이상으로 보내면 문제가 생긴다. 따라서 수신측에서 송신측에 수신 가능한 데이터의 양을 통지하고 그만큼만 윈도우 제어방식으로 보내면 된다. 이 통지하는 부분이 TCP헤더의 윈도우 필드다.

만일 4380바이트 만큼 버퍼에서 처리가 가능하다면 1460바이트의 세 패킷을 받습니다. 중간에 한 패킷이 처리가 되었다면 이를 다시 TCP헤더에 넘겨 1460만큼 비었다고 통지합니다. 그러면 이 빈 공간만큼 송신측에서 보내면 됩니다. 

그럼 이제 수신측에서 보내야하는 데이터가 두가지가 되었습니다. ACK번호와 윈도우입니다. 그런데 두가지가 계산되는 시점이 다릅니다. ACK는 패킷을 받자마자 처리가 가능한데 윈도우는 버퍼에서 처리 후에 공간을 비우고 빈 공간만큼을 통지해야 하기 때문에 두 값이 발생하는 시기가 다릅니다. 두 번 보내면 네트워크 효율이 떨어지므로 두 값을 합쳐서 패킷으로 묶어 보내게 됩니다. 그런데 그 와중에 다른 패킷이 넘어와 ACK번호가 바뀐다면 어떨까요? ACK번호는 순차적입니다. 2001번과 4001번은 이어집니다. 따라서 4001만 보내게 됩니다.

#### 수신

응답메시지를 수신하게 됩니다. read를 호출하게되면 이제 수신상태가 되며 송신할때와 마찬가지로 버퍼를 만들어 위와 같은 과정을 반대 측면에서 거치게 됩니다.

#### 참고자료

성공과 실패를 결정하는 1%의 네트워크원리, Tcutomu Tone, 이도희 옮김, 성안당