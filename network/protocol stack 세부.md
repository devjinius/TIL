# protocol stack

###큰 흐름

애플리케이션 레이어에서 요청을 받으면 OS는 프로토콜 스택에서 작업을 실행한다. 프로토콜 스택의 윗부분에는 TCP / UDP가 있으며 둘 다 데이터 송수신을 담당합니다. TCP는 일반적인 데이털르 송수신하는 것이며 UDP는 DNS서버와 같이 짧은 제어용 데이터를 송수신할 때 사용합니다.

그 뒤 IP 프로토콜을 이용하여 송 수신을 제어하고 이를 패킷으로 나누어 운반하게 됩니다. 패킷을 통신 상대까지 훈반하는 것이 IP의 역할입니다. IP안에서는 ICMP와 ARP라는 프로토콜을 다룹니다. 전자는 패킷을 운반할 때 발생하는 오류를 통지하거나 제어할때, 후자는 MAC주소를 조사할 때 사용합니다.

그 아래에는 LAN 드라이버가 있습니다. LAN 어댑터의 하드웨어를 제어합니다. 

### 프로토콜 스택과 소켓

프로토콜 스택은 내부에 제어정보를 기록하는 메모리 영역을 가지며 통신동작을 제어하기 위한 제어 정보를 기록합니다. 상대의 IP주소, 포트번호, 진행상태등을 기록합니다. 소켓의 경우 실체는 사실 없지만 이 제어정보를 소켓으로 볼 수 있습니다. 즉 파이프의 입구인 소켓은 특정한 실체는 없지만 이러한 제어정보들을 이야기합니다. cmd창에서 `netstat -ano`를 입력하면 나오는 정보들이 소켓입니다. PID(processID), protocol, ip주소, 상태와 같은 정보들을 저장합니다.

### socket & descriptor

`<디스크립터> = socket(<IPv4>, <TCP사용>, ...);`

이 부분이다. 소켓을 만드는 단계입니다. 소켓을 만든 뒤 커넥트하게 됩니다. 소켓을 만든다는 것은 프로토콜 스택이 메모리 영역을 확보하는 것입니다. 메모리를 확보하여 소켓을 만들고 이를 디스크립터를 반환하여 구분하게됩니다. 이후 프로토콜 스택에 어떤 동작을 의뢰할 때 디스크립터를 이용하게 됩니다.

### connect

만든 소켓으로 connect를 호출합니다. 그러면 프로토콜 스택은 클라이언트측 소켓을 서버측 소켓에 접속합니다. 

`connect(<디스크립터>, <서버의 IP주소와 포트번호>, ...);`

이 부분입니다. 접속은 서로의 제어 정보를 주고받아 데이터 송 수신이 가능한 상태로 만드는 것입니다. 클라이언트 측의 ip주소나 포트번호를 알리는 것이 그 예입니다. 구체적으로는 송 수신시 데이터를 일시적으로 저장하는 메모리 영역이 필요한데 이를 버퍼메모리라고 합니다. 이 버퍼메모리를 확보하는 것이 접속한다는 의미이기도 합니다.

####제어정보

서로의 제어 정보를 주고 받는다고 했는데 이 제어정보에는 크게 두 종류가 있습니다. 하나는 서로 연락을 절충하기 위해 주고받는 제어 정보입니다. 이는 보통 TCP헤더라고 부릅니다. 포트번호, 시퀀스번호, ACK, 컨트롤 비트 등이 포함됩니다. 다음으로는 소켓에 기록되는 정보입니다. 애플리케이션에서 통지된 정보, 상대로부터 받은 정보등이 수시로 진행됩니다. 또한 진행상황 등도 실시간으로 기록됩니다. 이 소켓 정보는 상대측에서 볼 수는 없습니다. 헤더의 경우 서로가 주고받지만 소켓정보는 OS마다 다르기 때문에 주고받지 않고 서로 모릅니다.

* 헤더에 기입되는 정보
* 소켓에 기록되는 정보

#### 접속동작의 실체

애플리케이션 레이어에서 connect를 실행하게되면 프로토콜 스택에게 의뢰하여 헤더를 만들게 됩니다. TCP 헤더에 있어 중요한 것은 송신처와 수신처의 포트번호입니다. 

그 후 SYN이라는 컨트롤 비트를 1로 만든 뒤 TCP헤더를 다 만들고 이를 IP에게 건네주게 됩니다. 그렇게 넘어간 헤더는 서버측 TCP까지 도달하고  수신처의 포트번호를 조사해 소켓을 찾아 이에 알려주게 됩니다. 클라이언트와 마찬가지로 서버측에서도 헤더를 만들고 ACK를 1로 만들어 응답합니다. 이는 패킷을 받았다는 것을 알리는 정보입니다. 새로만든 응답 TCP헤더를 IP에게 전달하여 같은 과정으로 응답하게 됩니다.

돌아온 패킷은 클라이언트 TCP까지 도달하게 되고 TCP헤더를 조사하여 접속이 성공했는지 확인합니다. SYN이 1이면 접속 성공이므로 서버의 IP주소나 포트번호등과 함께 관련 정보를 기록하고 마지막으로 잘 받았다는 표시로 ACK비트를 1로 만든 패킷(방금받은 그 패킷)의 TCP헤더를 반송합니다.  이 과정으로 접속이 완료됩니다. 이제 소켓을 찾아 파이프를 만든 것이고 데이터를 송수신하기위한 준비가 끝나게 됩니다. 단순히 한번의 통신이 아닌 세번의 통신을 거쳐 접속 후 정보를 주고받게 됩니다. 이는 close를 호출하기 전 까지 연결이 지속됩니다.

#### 참고자료

성공과 실패를 결정하는 1%의 네트워크원리, Tcutomu Tone, 이도희 옮김, 성안당