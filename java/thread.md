# Thread

## process & thread

프로세스란 실행중인 프로그램을 얘기한다. 프로그램을 실행하면 수행하는데 필요한 데이터와 메모리같은 자원을 받아 프로세스가 된다. 이 프로세스는 할당받은 자원과 쓰레드로 구성된다. 그래서 모든 프로세스는 하나 이상의 쓰레드가 존재한다.

쓰레드는 이렇게 실제로 작업을 수행하는 것을 이야기한다. 

*프로세스가 공장이라면 쓰레드는 일꾼이다.* 

현실세계에선 일꾼이 많으면 일이 엄청 빨라지지만 쓰레드는 좀 다르다. 그 이유는 context switching때문인데 이 것때문에 싱글코어에서는 오히려 느려진다.

### 멀티태스킹과 멀티쓰레딩

우리가 사용하는 OS들은 멀티태스킹을 지원한다. 한번에 프로세스가 동시에 여러개가 실행되어 그렇게 이야기한다. 멀티쓰레딩도 마찬가지다. 하나의 프로세스에서 여러 쓰레드가 동시에 작업을 수행하는 것이다. CPU의 코어가 아주 짧은 시간동안 여러 작업을 번갈아 가며 수행하기에 모두 동시에 처리되는것 처럼 보이게 된다.

### 멀티쓰레딩의 장점

1. CPU의 사용률 향상
2. 자원을 효율적으로 이용
3. 사용자 응답성 향상
4. 코드가 간결해짐

이 멀티쓰레딩 덕에 우리는 채팅하면서 파일을 다운받을 수 있다.

그렇지만 아까도 얘기했듯 context switching, synchronization, deadlock(교착상태: 서로 같은 자원을 점유하여 상대방의 사용종료를 기다리는 상태) 들로 더 낮은 효율을 보일 수 있다.

## Thread의 구현과 실행

구현하는 방법은 Thread 클래스 상속과 Runnable 인터페이스 구현이 있다. 클래스 상속은 크게 다르지 않지만 인터페이스 구현은 조금 다르다. 코드를 보자

```java
ThreadEx1_1 t1 = new ThreadEx1_1(); // Thread 상속받은 클래스 인스턴스 생성
Thread t2 = new Thread(new ThreadEx1_2()); 
// Runnable을 구현한 클래스의 인스턴스를 매개변수로 Thread 클래스 생성자 호출
```

인터페이스를 구현한 클래스를 그대로 사용하는 것이 아니라 Thread 객체를 만들어 낸다. 그 이유는 Runnable의 소스를 보면 알 수 있다.

`public interface Runnable {public abstract void run();}`

Runnable은 이게 다다. 그래서 인터페이스를 구현할 경우 run메서드만 구현하면 간단하다. 대신 그 외의 많은 메서드 들을 이용할 수 없기 때문에 매개변수로 Thread객체를 생성하는 것이다.

**Runnable을 구현할 경우 Thread 클래스의 static 메서드인 currentThread를 호출하여 쓰레드를 얻어와야만 호출이 가능하다.** 왜냐하면 멤버가 run() 밖에 없기 때문에 그냥 호출이 안된다.

`System.out.prinln(Thread.currentThread.getName());`

쓰레드는 이름을 지정하면 이름이 생긴다. 딱히 지정하지 않으면 default값으로 Thread-번호가 지정된다.

#### start()

앞에서 구현은 run()을 했지만 실행은 start()로 한다. 그 이유는 run()은 단순히 Thread를 실행하는 메서드인데 start()는 callstack을 만들어주는 메서드다. start()로 callstack을 만들고 그 위에 run()메서드를 호출하여 쓰레드를 실행해야 일꾼이 두명이 된다. 그냥 메인 콜스택에 실행하면 아무 효과가 없다.

start는 한번만 호출이 가능하다. 한번 실행이 종료된 쓰레드는 다시 실행할 수 없는 것이다. 만일 다시 실행하고자 한다면,

```java
Thread t1 = new Thread();
t1.start();
t1 = new Thread();
t1.start();
```

이렇게 다시 새로 생성해서 사용하면 된다. 

#### main Thread

메인을 작업하는 콜스택도 쓰레드다. 우리는 이를 메인쓰레드 라고 부른다. 지금까진 메인메서드가 종료되면 프로그램이 종료되었지만 새로운 쓰레드를 만들고 그 쓰레드가 아직 실행중이라면 메인이 끝나도 프로그램이 끝나지 않는다. 즉 *실행 중인 사용자 쓰레드가 하나도 없을 때 프로그램은 종료된다.*

### 싱글쓰레드와 멀티쓰레드

두 쓰레드가 같은 자원을 사용하는 경우 쓰레드를 나누는 것은 그다지 좋지 않다. 또 싱글코어의 경우도 마찬가지다. 쓰레드를 생성하나마나 의미가 없다. 

하지만 두 쓰레드가 서로 다른 자원을 사용하는 작업의 경우 멀티쓰레드가 큰 힘을 가진다. 예를들어 데이터를 입력받는다던가, 파일을 주고받는 경우, 프린터로 출력하는 경우가 이에 해당한다. 아까 말한 채팅하면서 파일을 보내며 영상통화를 하는 것과 같은경우도 이에 해당한다. 서로 다른 자원을가지고 각자의 작업을 수행하는 경우 굉장히 큰 효율을 보인다. 

### 쓰레드의 우선순위

쓰레드는 priority라는 멤버번수를 가진다. 이 우선순위에 따라 얻는 시간이 달라진다. main메서드 내에서 생성하는 쓰레드의 우선순위는 5이며 우선순위는 1~10이다. 높은 숫자일수록 우선순위가 높다.

`void setPriority(10);//우선순위 설정`



