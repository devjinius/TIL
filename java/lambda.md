# lambda

함수형 언어의 기능을 갖추게 하는 기능이다.

람다식이란 함수를 간략하면서도 명확한 식으로 표현할 수 있게 해주는 식! 이다.

메서드의 이름과 반환값을 없애 익명함수를 만드는 것이다.

``` java
int[] arr = new int[5];
Arrays.setAll(arr, () -> (int)(Math.random*5)+1);
// 이렇게 () -> 생긴 친구를 람다식이라 한다.
int method() {
  return (int)(Math.random()*5) + 1;
}
// 하는일은 이 메서드와 같다.
```

람다의 특징으로는 메서드의 매개변수로 전달되어지는 것이 가능하다. 또 메서드가 반환 될 수도 있다. 즉 메서드를 변수처럼 다루는 것인데, 그 이유는 람다가 객체기 때문이다. 람다식으로 표현하면 메서드도 객체가 된다. 객체기 때문에 파라미터, 반환값으로도 가능한 것이다.

### 람다식으로 변경과 생략

```java
int max(int a, int b){
  return a > b ? a : b;
}//이러한 메서드를

(a, b) -> a > b ? a : b // 이렇게 변경하면 된다.
```

반환값이 있는 메서드의 경우 식으로 return을 대신한다.  return'문'이 아니기 때문에 세미콜론은 붙이지 않는다.

*함수형 프로그래밍의 궁극?점은 반환값이 없는 메서드를 최소화 하는 것이다.*

매개변수의 경우도 추론이 가능한 경우 생략하고 반환타입도 마찬가지로 생략할 수 있다.

매개변수가 하나면 괄호도 생략할 수 있다. 단 타입을 적으면 괄호가 필요하다.

{}안의 문장이 하나면 생략 가능하다.

### 함수형 인터페이스

람다는 메서드 같지만 사실은 함수형 인터페이스의 객체다. 이 인터페이스에는 하나의 추상메서드만 존재할 수 있고 그게바로 람다식이다. 우리가 사용할 때 혹은 사용하기 전에 그 메서드를 () -> 이러한 표현으로 구현해주는 것이다. 

인터페이스의 객체니까 참조변수에 저장할 수 도 있을 것이다. 그렇다면 이 참조변수의 타입은 어떻게 될까? 

당연히 람다식과 동등한 메서드가 정의된 클래스나 인터페이스가 되어야 한다.

```java
@FunctionalInterface //함수형 인터페이스
interface MyFunction{
  public abstract int max(int a, int b);
}

psvm{
  MyFunction f = new MyFunction(){
    public int max(int a, int b){
      return a > b ? a : b;
    }
  }
}

// 이렇게 객체를 생성하여 참조변수에 저장하는 것이다. 이를 간단하게 표현하면 아래와 같다.

psvm{
  My function f = (a, b) -> a > b ? a : b
  int big = f.big(5, 3);
}
```

##### 매개변수와 반환타입

만일 함수의 매개변수가 함수형 인터페이스라면 메서드를 호출할 때 람다식을 참조하는 참조변수로 지정해주어야 하거나 람다식을 매개변수로 넘겨야 한다.

`void method(Myfunction f){}` 일경우 `method(Myfunction myf)`이거나 `method( () -> {} )` 이렇게 말이다. 사실 당연한 거다.

또 반환타입이 함수형 인터페이스라면 람다식을 참조하는 참조변수거나 람다식이 직접 반환된다.

다시 말하지만 당연한거다. 메서드를 매개변수로 주고 반환 받는 것 처럼 보이지만 람다는 객체다. 그러기에 자연스러워야 한다.

### 타입과 형변환

람다는 익명 객체다. 따라서 타입이 없다. 정확히는 타입은 있는데 컴파일러가 임의로 타입 이름을 정하기 때문에 알 수 없어서 그냥 없다고 보자.

정리하자면 람다는 객체이지만 타입이 없는 객체인 것이다. 따라서 Object타입으로 형변환 할 수 없다. 모든 타입은 Object 아래에 있는데 람다는 타입이 없기에 Object로 안된다. 람다는 오직 함수형 인터페이스로만 형변환이 가능하다. `MyFunction f = (MyFuction) () -> {}` 이렇게 말이다. 물론 생략 가능하다.

굳이 Object로 바꾸고 싶다면 먼저 함수형 인터페이스로 변환하고 난 뒤에 가능하다. 

`String str = ((Object)(MyFunction)(() -> {})).toString;` 이렇게 말이다.

### 람다의 지역변수

**참고로 람다식 내에서 람다가 참조하는 지역변수들은 final이 자동으로 붙게 된다.**

이는 불변(immortal)의 개념때문이다. 위에서 반환값이 없는 메소드를 최소화 한다고 했다. 그 이유가 불변과 관련되어 있다.

반환값이 없는 메서드는 다른 메서드와 충돌 가능성이 있다. 값이 변하는 변수도 마찬가지다. 애초에 반환하는 메서드만 만들고 상수만 이용한다면 사이드 이펙트의 가능성이 비교할 수 없을 정도로 낮아진다. 이와 관련해서는 *나는프로그래머다* 1권을 참고하자. 임백준 저자님께서 잘 설명 해주셨다. 

함수형 프로그래밍의 핵심은 사이드 이펙트를 줄일 수 있단점이라고 생각한다. 따라서 불변과 참조투명성을 보장하는 코딩이 수반되어야 진정한 함수형 프로그래밍이라고 생각한다. 객체지향 프로그래밍 언어인 자바로는 한계가 있다고 생각한다. 나중에 함수형 프로그래밍 언어를 공부하며 다시 정리해 보자. 

SCALA!!!!!!!

